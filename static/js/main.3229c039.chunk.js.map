{"version":3,"sources":["utils/microbit-api.js","components/AddMicroButton/index.js","components/MicrobitGraph/components/PlayButton/index.js","components/MicrobitGraph/components/SaveData/index.js","components/MicrobitGraph/components/DisconnectMicroButton/index.js","components/MicrobitGraph/components/BrushChart/index.js","components/MicrobitGraph/components/Title/index.js","components/MicrobitGraph/index.js","components/StickyStatistics/index.js","containers/Home/App.js","utils/serviceWorker.js","index.js"],"names":["Promise","delay","duration","resolve","reject","setTimeout","DAPOutReportRequest","requestType","recipient","request","value","index","DAPInReportRequest","uBitConnectDevice","callback","navigator","usb","requestDevice","filters","vendorId","productId","then","d","opened","device","buffer","decoder","TextDecoder","parser","controlTransferOutFN","data","controlTransferOut","open","selectConfiguration","claimInterface","Uint8Array","from","transferLoop","controlTransferIn","status","arr","length","len","msg","slice","string","decode","firstNewline","indexOf","messageToNewline","now","Date","parseResult","exec","graph","series","callbackType","isNaN","parseFloat","time","catch","error","close","uBitOpenDevice","AddMicroButton","props","Button","size","onClick","e","onAddComplete","Icon","name","PlayButton","this","isRunning","icon","labelPosition","color","style","width","Component","SaveDataButton","csvData","fileName","wb","Sheets","XLSX","json_to_sheet","SheetNames","excelBuffer","bookType","type","Blob","FileSaver","exportToCSV","DisconnectMicroButton","disconnectDevice","BrushChart","options","optionsLine","seriesLine","height","chart","Title","Container","textAlign","Header","content","title","MicrobitGraph","Table","definition","Body","Row","Cell","verticalAlign","playOnClick","Divider","hidden","SaveData","moment","format","bind","Statistic","Value","Label","areaHeight","StickyStatistics","Segment","backgroundColor","Rail","position","Sticky","Group","microbitsConnected","App","contextRef","createRef","state","devices","graphs","id","toolbar","autoSelected","show","colors","stroke","dataLabels","enabled","fill","opacity","markers","xaxis","categories","brush","target","selection","gradient","opacityFrom","opacityTo","tooltip","yaxis","tickAmount","seconds","microbitCallBack","serialNumber","setState","createGraph","uBitDisconnect","undefined","deviceSerial","timeElapsed","map","val","key","as","inverted","Subheader","Object","keys","React","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"qbAQAA,QAAQC,MAAQ,SAASC,GACrB,OAAO,IAAIF,SAAQ,SAASG,EAASC,GACjCC,YAAW,WACPF,MACDD,OAIX,IAcMI,EAAsB,CACxBC,YAAa,QACbC,UAAW,YACXC,QAZ6B,EAa7BC,MAZ6B,IAa7BC,MAjB2B,GAoBzBC,EAAsB,CACxBL,YAAa,QACbC,UAAW,YACXC,QArB6B,EAsB7BC,MAnB4B,IAoB5BC,MAzB2B,GA2KxB,SAASE,EAAkBC,GAC9BC,UAAUC,IAAIC,cAAc,CAACC,QAAS,CAAC,CAAEC,SA9KlB,KA8KgDC,UAAW,QAC7EC,MAAO,SAAAC,GAAWA,EAAEC,QA7I7B,SAAwBC,EAAQV,GAC5B,IAAIW,EAAO,GACPC,EAAU,IAAIC,YAAY,SACxBC,EAAS,2BAgEf,SAASC,EAAqBC,GAC1B,OAAO,WAAQ,OAAON,EAAOO,mBAAmBzB,EAAqBwB,IAGzEN,EAAOQ,OACAX,MAAK,kBAAMG,EAAOS,oBAAoB,MACtCZ,MAAK,kBAAMG,EAAOU,eAAe,MACjCb,KAAKQ,EAAqBM,WAAWC,KAAK,CAAC,EAAG,MAC9Cf,KAAKQ,EAAqBM,WAAWC,KAAK,CAAC,GAAM,IAAM,IAAM,IAAM,MACnEf,KAAKQ,EAAqBM,WAAWC,KAAK,CAAC,GAAM,MACjDf,KAAKQ,EAAqBM,WAAWC,KAAK,CAAC,IAAM,EAAM,IAAM,EAAM,MACnEf,MAAK,WAA6C,OAArCP,EAAS,YAAaU,EAAQ,MAAcxB,QAAQG,aACjEkB,MA1EY,SAAfgB,IACAb,EAAOO,mBAAmBzB,EAAqB6B,WAAWC,KAAK,CAAC,OAC7Df,MAAK,kBAAMG,EAAOc,kBAAkB1B,EAAoB,OACxDS,MAAK,SAACS,GACL,GAAmB,MAAfA,EAAKS,OACL,OAAOvC,QAAQC,MAnCH,KAmC8BoB,KAAKgB,GAInD,IAAIG,EAAM,IAAIL,WAAWL,EAAKA,KAAKL,QACnC,GAAGe,EAAIC,OAAO,EACV,OAAOzC,QAAQC,MAxCI,KAwC8BoB,KAAKgB,GAG1D,IAAIK,EAAMF,EAAI,GACd,GAAQ,GAALE,EACC,OAAO1C,QAAQC,MA7CI,KA6C8BoB,KAAKgB,GAM1D,IAJA,IAAIM,EAAMH,EAAII,MAAM,EAAE,EAAEF,GACpBG,EAAUnB,EAAQoB,OAAOH,GAEzBI,GADJtB,GAAUoB,GACgBG,QAAQ,MAC5BD,GAAc,GAAG,CACnB,IAAIE,EAAmBxB,EAAOmB,MAAM,EAAEG,GAClCG,EAAM,IAAIC,KAGVC,EAAcxB,EAAOyB,KAAKJ,GAC9B,GAAGG,EAAa,CACZ,IAAIE,EAAQF,EAAY,GACpBG,EAASH,EAAY,GACrBtB,EAAOsB,EAAY,GACnBI,EAAe,cAEfC,MAAM3B,KACN0B,EAAe,aACf1B,EAAO4B,WAAW5B,IAStBhB,EAAS0C,EAAchC,EANN,CACbmC,KAAMT,EACNI,MAAOA,EACPC,OAAQA,EACRzB,KAAMA,QAGP,CAGHhB,EAAS,UAAWU,EADH,CAACmC,KAAMT,EAAKpB,KAAMmB,IAKvCF,GADAtB,EAASA,EAAOmB,MAAMG,EAAa,IACbC,QAAQ,MAGlC,OAAOhD,QAAQC,MApFE,IAoF0BoB,KAAKgB,MAGnDuB,OAAM,SAAAC,GAAcrC,EAAOD,QAAQT,EAAS,QAASU,EAAQqC,GAAQrC,EAAOsC,QAAShD,EAAS,eAAgBU,EAAQ,YAgBpHoC,OAAM,SAAAC,GAAK,OAAI/C,EAAS,QAASU,EAAQqC,MA6DfE,CAAezC,EAAGR,MAC9C8C,OAAO,kBAAM9C,EAAS,qBAAsB,KAAM,SCnLpD,SAASkD,EAAeC,GAK7B,OACE,kBAACC,EAAA,EAAD,CAAQC,KAAK,MAAMC,QAAS,SAACC,GAJ7BxD,EAAkBoD,EAAMK,iBAKtB,kBAACC,EAAA,EAAD,CAAMC,KAAK,SADb,iB,sBCSWC,E,iLAvBX,OAAOC,KAAKT,MAAMU,UACd,kBAACT,EAAA,EAAD,CACEU,MAAI,EACJC,cAAc,OACdT,QAASM,KAAKT,MAAMG,QACpBU,MAAM,OAEN,kBAACP,EAAA,EAAD,CAAMC,KAAK,UANb,SASA,kBAACN,EAAA,EAAD,CACEU,MAAI,EACJC,cAAc,OACdT,QAASM,KAAKT,MAAMG,QACpBU,MAAM,QACNC,MAAO,CAACC,MAAO,aAEf,kBAACT,EAAA,EAAD,CAAMC,KAAK,SAPb,Y,GAZiBS,a,iBC6BVC,E,iLA1BF,IAAD,OAWR,OACE,kBAAChB,EAAA,EAAD,CACEU,MAAI,EACJC,cAAc,OACdT,QAAS,SAACC,GAAD,OAXO,SAACc,EAASC,GAC1B,IACMC,EAAK,CAAEC,OAAQ,CAAE,KADZC,QAAWC,cAAcL,IACCM,WAAY,CAAC,SAC5CC,EAAcH,QAAWF,EAAI,CAAEM,SAAU,MAAOC,KAAM,UACtD9D,EAAO,IAAI+D,KAAK,CAACH,GAAc,CAACE,KAPzB,oFAQbE,SAAiBhE,EAAMsD,EAPL,QAaHW,CAAY,EAAK9B,MAAMkB,QAAS,EAAKlB,MAAMmB,WAC1DN,MAAM,OACNC,MAAO,CAACC,MAAO,aAEf,kBAACT,EAAA,EAAD,CAAMC,KAAK,SAPb,Y,GAbuBS,aCUde,MAZR,SAA+B/B,GAKpC,OACE,kBAACC,EAAA,EAAD,CAAQC,KAAK,MAAMC,QAAS,SAACC,GAJ7BJ,EAAMgC,iBAAiBhC,EAAMzC,UAI7B,sB,iBCUW0E,E,iLAdX,OACE,6BACE,kBAAC,IAAD,CAAOC,QAASzB,KAAKT,MAAMkC,QAAS5C,OAAQmB,KAAKT,MAAMV,SACvD,kBAAC,IAAD,CACE4C,QAASzB,KAAKT,MAAMmC,YACpB7C,OAAQmB,KAAKT,MAAMoC,WACnBT,KAAK,OACLU,OAAQ5B,KAAKT,MAAMmC,YAAYG,MAAMD,c,GATtBrB,a,kBCUVuB,E,iLARX,OACI,kBAACC,EAAA,EAAD,CAAWC,UAAU,UACjB,kBAACC,EAAA,EAAD,CAAQC,QAASlC,KAAKT,MAAM4C,MAAO1C,KAAK,OAAOY,MAAO,CAACD,MAAO,e,GAJtDG,aC8DL6B,E,iLAtDX,OACE,6BACE,kBAACL,EAAA,EAAD,KACE,kBAAC,EAAD,CAAOI,MAAOnC,KAAKT,MAAM4C,QACzB,kBAACE,EAAA,EAAD,CAAOC,YAAU,EAACN,UAAU,UAC1B,kBAACK,EAAA,EAAME,KAAP,KACE,kBAACF,EAAA,EAAMG,IAAP,KACE,kBAACH,EAAA,EAAMI,KAAP,CAAYnC,MAAO,EAAGoC,cAAc,OAClC,kBAAC,EAAD,CACEzC,UAAWD,KAAKT,MAAMU,UACtBP,QAASM,KAAKT,MAAMoD,cAGtB,kBAACC,EAAA,EAAD,CAASC,QAAM,IAEf,kBAACC,EAAD,CACErC,QAAST,KAAKT,MAAMkB,QACpBC,SAAU,qBAAuBqC,MAASC,OAAO,WAGnD,kBAACJ,EAAA,EAAD,CAASC,QAAM,IAEf,kBAAC,EAAD,CACE/F,OAAQkD,KAAKT,MAAMzC,OACnByE,iBAAkBvB,KAAKT,MAAMgC,iBAAiB0B,KAAKjD,QAGrD,kBAACkD,EAAA,EAAD,CAAWzD,KAAK,OAAOY,MAAO,IAC5B,kBAAC6C,EAAA,EAAUC,MAAX,KACE,kBAACtD,EAAA,EAAD,CAAMC,KAAK,kBADb,MAGA,kBAACoD,EAAA,EAAUE,MAAX,uBAGJ,kBAACf,EAAA,EAAMI,KAAP,KACE,kBAAC,EAAD,CACEhB,QAASzB,KAAKT,MAAMkC,QACpB5C,OAAQmB,KAAKT,MAAMV,OACnB6C,YAAa1B,KAAKT,MAAMmC,YACxBC,WAAY3B,KAAKT,MAAMoC,WACvBC,OAAQ5B,KAAKT,MAAMqC,OACnByB,WAAYrD,KAAKT,MAAM8D,kBAOnC,kBAACT,EAAA,EAAD,CAASC,QAAM,S,GAlDKtC,a,kBC0Bb+C,E,iLAvBX,OACE,kBAACvB,EAAA,EAAD,KACE,kBAACwB,EAAA,EAAD,CAASlD,MAAO,CAAEmD,gBAAiB,YACjC,kBAACC,EAAA,EAAD,CAAMC,SAAS,SACb,kBAACC,EAAA,EAAD,KACE,kBAACJ,EAAA,EAAD,CAASvB,UAAU,UACjB,kBAACkB,EAAA,EAAUU,MAAX,KACE,kBAACV,EAAA,EAAD,KACE,kBAACA,EAAA,EAAUC,MAAX,KACE,kBAACtD,EAAA,EAAD,CAAMC,KAAK,QADb,IACuBE,KAAKT,MAAMsE,oBAElC,kBAACX,EAAA,EAAUE,MAAX,uC,GAbW7C,aC4LhBuD,E,YA3Lb,WAAYvE,GAAQ,IAAD,8BACjB,4CAAMA,KA6HRwE,WAAaC,sBA5HX,EAAKC,MAAQ,CAEXC,QAAS,GACTjE,WAAW,EACX4D,mBAAoB,EACpBM,OAAQ,GACR1C,QAAS,CACPI,MAAO,CACLuC,GAAI,SACJlD,KAAM,OACNU,OAAQ,IACRyC,QAAS,CACPC,aAAc,MACdC,MAAM,IAGVC,OAAQ,CAAC,WACTC,OAAQ,CACNnE,MAAO,GAEToE,WAAY,CACVC,SAAS,GAEXC,KAAM,CACJC,QAAS,GAEXC,QAAS,CACPrF,KAAM,GAERsF,MAAO,CACL7D,KAAM,OACN8D,WAAY,KAIhBrD,WAAY,CACV,CACEvE,KAAM,CACJ,2BACA,2BACA,6BAINsE,YAAa,CACXG,MAAO,CACLuC,GAAI,SACJxC,OAAQ,IACRV,KAAM,OACN+D,MAAO,CACLC,OAAQ,SACRP,SAAS,GAEXQ,UAAW,CACTR,SAAS,IAGbH,OAAQ,CAAC,WACTI,KAAM,CACJ1D,KAAM,WACNkE,SAAU,CACRC,YAAa,IACbC,UAAW,KAGfP,MAAO,CACL7D,KAAM,OACNqE,QAAS,CACPZ,SAAS,IAGba,MAAO,CACLC,WAAY,IAGhBC,QAAS,GAGX,EAAKC,iBAAmB,EAAKA,iBAAiB1C,KAAtB,gBAhFP,E,8EAmFF/B,EAAMpE,EAAQM,GAC7B,GAAa,cAAT8D,EAAsB,CACxB,IAAIgD,EAAUlE,KAAKiE,MAAMC,QACzBA,EAAQpH,EAAO8I,cAAgB9I,EAC/BkD,KAAK6F,SAAS,CAAE3B,QAASA,IACzBlE,KAAK8F,YAAYhJ,M,uCAIJA,ITkCZ,SAAwBA,GACxBA,GAAUA,EAAOD,QAChBC,EAAOsC,QSnCX2G,CAAejJ,GACf,IAAIoH,EAAUlE,KAAKiE,MAAMC,QACrBC,EAASnE,KAAKiE,MAAME,cACjBD,EAAQpH,EAAO8I,qBACfzB,EAAOrH,EAAO8I,cACrB5F,KAAK6F,SAAS,CACZ1B,OAAQA,EACRD,QAASA,EACTL,mBAAoB7D,KAAKiE,MAAMJ,mBAAqB,M,kCAI5C/G,GACV,QAA+CkJ,IAA3ChG,KAAKiE,MAAME,OAAOrH,EAAO8I,cAA6B,CACxD,IAAIzB,EAASnE,KAAKiE,MAAME,OACxBA,EAAOrH,EAAO8I,cAAgB,CAC5BK,aAAcnJ,EAAO8I,aACrBzD,MAAO,mBAAqBrF,EAAOL,SACnCwD,WAAW,EACXiG,YAAa,EACbrH,OAAQ,CACN,CACEzB,KAAM,MAIZ4C,KAAK6F,SAAS,CACZ1B,OAAQA,EACRN,mBAAoB7D,KAAKiE,MAAMJ,mBAAqB,O,+BAOhD,IAAD,OAGHpD,EAFM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAER0F,KAAI,SAASC,EAAKnK,GAClC,MAAO,CAAEoK,IAAKpK,EAAOD,MAAOoK,EAAMA,MAG9BjC,EAASnE,KAAKiE,MAAME,OAE1B,OACE,6BACE,kBAAClC,EAAA,EAAD,CAAQqE,GAAG,KAAKpG,MAAI,EAACqG,UAAQ,EAACvE,UAAU,UACtC,kBAACnC,EAAA,EAAD,CAAMC,KAAK,eADb,yBAGE,kBAACmC,EAAA,EAAOuE,UAAR,4DAIF,kBAAC5D,EAAA,EAAD,MACA,kBAAC,EAAD,CACEiB,mBAAoB7D,KAAKiE,MAAMJ,mBAC/BqC,YAAalG,KAAKiE,MAAMiC,cAE1B,kBAACnE,EAAA,EAAD,KACE,kBAACzC,EAAD,CAAgBM,cAAeI,KAAK2F,mBACnCxB,GACCsC,OAAOC,KAAKvC,GAAQgC,KAAI,SAACE,EAAKpK,GAC5B,OACE,6BACE,kBAAC,EAAD,CACEa,OAAQ,EAAKmH,MAAMC,QAAQmC,GAC3BlE,MAAOgC,EAAOkC,GAAKlE,MACnB1B,QAASA,EACTgB,QAAS,EAAKwC,MAAMxC,QACpB5C,OAAQsF,EAAOkC,GAAKxH,OACpB6C,YAAa,EAAKuC,MAAMvC,YACxBC,WAAY,EAAKsC,MAAMtC,WACvBC,OAAQ,EAAKqC,MAAMrC,OACnByB,WAAY,EAAKY,MAAMZ,WACvBpD,UAAWkE,EAAOkC,GAAKpG,UACvB0C,YAAa,WACXwB,EAAOkC,GAAKpG,WAER,EACJ,EAAK4F,SAAS,CACZ1B,OAAQA,KAGZ5C,iBAAkB,EAAKA,iBAAiB0B,KAAK,e,GAjL/C0D,IAAMpG,WCEJqG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmB/K,WACrBA,UAAUgL,cAAcC,MAAM3K,MAAK,SAAA4K,GACjCA,EAAaC,kB","file":"static/js/main.3229c039.chunk.js","sourcesContent":["\r\n/*\r\n * JavaScript functions for interacting with micro:bit microcontrollers over WebUSB\r\n * (Only works in Chrome browsers;  Pages must be either HTTPS or local)\r\n */\r\n\r\n// Add a delay() method to promises \r\n// NOTE: I found this on-line somewhere but didn't note the source and haven't been able to find it!\r\nPromise.delay = function(duration){\r\n    return new Promise(function(resolve, reject){\r\n        setTimeout(function(){\r\n            resolve();\r\n        }, duration)\r\n    });\r\n}\r\n\r\nconst MICROBIT_VENDOR_ID = 0x0d28\r\nconst MICROBIT_PRODUCT_ID = 0x0204\r\nconst MICROBIT_DAP_INTERFACE = 4\r\n\r\nconst controlTransferGetReport = 0x01\r\nconst controlTransferSetReport = 0x09\r\nconst controlTransferOutReport = 0x200\r\nconst controlTransferInReport = 0x100\r\n\r\nconst uBitBadMessageDelay = 500         // Delay if message failed\r\nconst uBitIncompleteMessageDelay = 150  // Delay if no message ready now\r\nconst uBitGoodMessageDelay = 20         // Time to try again if message was good\r\n\r\n\r\nconst DAPOutReportRequest = {\r\n    requestType: \"class\",\r\n    recipient: \"interface\",\r\n    request: controlTransferSetReport,\r\n    value: controlTransferOutReport,\r\n    index: MICROBIT_DAP_INTERFACE\r\n}\r\n\r\nconst DAPInReportRequest =  {\r\n    requestType: \"class\",\r\n    recipient: \"interface\",\r\n    request: controlTransferGetReport,\r\n    value: controlTransferInReport,\r\n    index: MICROBIT_DAP_INTERFACE\r\n}\r\n\r\n\r\n/*\r\n   Open and configure a selected device and then start the read-loop\r\n */\r\nfunction uBitOpenDevice(device, callback) {\r\n    let buffer=\"\"                               // Buffer of accumulated messages\r\n    let decoder = new TextDecoder(\"utf-8\")      // Decoder for byte->utf conversion\r\n    const parser = /([^.:]*)\\.*([^:]+|):(.*)/   // Parser to identify time-series format (graph:info or graph.series:info)\r\n\r\n    let transferLoop = function () {\r\n        device.controlTransferOut(DAPOutReportRequest, Uint8Array.from([0x83])) // DAP ID_DAP_Vendor3: https://github.com/ARMmbed/DAPLink/blob/0711f11391de54b13dc8a628c80617ca5d25f070/source/daplink/cmsis-dap/DAP_vendor.c\r\n          .then(() => device.controlTransferIn(DAPInReportRequest, 64))\r\n          .then((data) => { \r\n            if (data.status != \"ok\") {\r\n                return Promise.delay(uBitBadMessageDelay).then(transferLoop);\r\n            }\r\n            // First byte is echo of get UART command: Ignore it\r\n\r\n            let arr = new Uint8Array(data.data.buffer)\r\n            if(arr.length<2)  // Not a valid array: Delay\r\n                return Promise.delay(uBitIncompleteMessageDelay).then(transferLoop)\r\n\r\n            // Data: Process and get more\r\n            let len = arr[1]  // Second byte is length of remaining message\r\n            if(len==0) // If no data: Delay\r\n                return Promise.delay(uBitIncompleteMessageDelay).then(transferLoop)\r\n            \r\n            let msg = arr.slice(2,2+len)  // Get the actual UART bytes\r\n            let string =  decoder.decode(msg);\r\n            buffer += string;\r\n            let firstNewline = buffer.indexOf(\"\\n\")\r\n            while(firstNewline>=0) {\r\n                let messageToNewline = buffer.slice(0,firstNewline)\r\n                let now = new Date() \r\n                // Deal with line\r\n                // If it's a graph/series format, break it into parts\r\n                let parseResult = parser.exec(messageToNewline)\r\n                if(parseResult) {\r\n                    let graph = parseResult[1]\r\n                    let series = parseResult[2]\r\n                    let data = parseResult[3]\r\n                    let callbackType = \"graph-event\"\r\n                    // If data is numeric, it's a data message and should be sent as numbers\r\n                    if(!isNaN(data)) {\r\n                        callbackType = \"graph-data\"\r\n                        data = parseFloat(data)\r\n                    }\r\n                    // Build and send the bundle\r\n                    let dataBundle = {\r\n                        time: now,\r\n                        graph: graph, \r\n                        series: series, \r\n                        data: data\r\n                    }\r\n                    callback(callbackType, device, dataBundle)\r\n                } else {\r\n                    // Not a graph format.  Send it as a console bundle\r\n                    let dataBundle = {time: now, data: messageToNewline}\r\n                    callback(\"console\", device, dataBundle)\r\n                }\r\n\r\n                buffer = buffer.slice(firstNewline+1)  // Advance to after newline\r\n                firstNewline = buffer.indexOf(\"\\n\")    // See if there's more data\r\n            }\r\n            // Delay long enough for complete message\r\n            return Promise.delay(uBitGoodMessageDelay).then(transferLoop);\r\n        })\r\n        // Error here probably means micro:bit disconnected\r\n        .catch(error => { if(device.opened) callback(\"error\", device, error); device.close(); callback(\"disconnected\", device, null);});\r\n    }\r\n\r\n    function controlTransferOutFN(data) {\r\n        return () => { return device.controlTransferOut(DAPOutReportRequest, data) }\r\n    }\r\n    \r\n    device.open()\r\n          .then(() => device.selectConfiguration(1))\r\n          .then(() => device.claimInterface(4))\r\n          .then(controlTransferOutFN(Uint8Array.from([2, 0])))  // Connect in default mode: https://arm-software.github.io/CMSIS_5/DAP/html/group__DAP__Connect.html\r\n          .then(controlTransferOutFN(Uint8Array.from([0x11, 0x80, 0x96, 0x98, 0]))) // Set Clock: 0x989680 = 10MHz : https://arm-software.github.io/CMSIS_5/DAP/html/group__DAP__SWJ__Clock.html\r\n          .then(controlTransferOutFN(Uint8Array.from([0x13, 0]))) // SWD Configure (1 clock turn around; no wait/fault): https://arm-software.github.io/CMSIS_5/DAP/html/group__DAP__SWD__Configure.html\r\n          .then(controlTransferOutFN(Uint8Array.from([0x82, 0x00, 0xc2, 0x01, 0x00]))) // Vendor Specific command 2 (ID_DAP_Vendor2): https://github.com/ARMmbed/DAPLink/blob/0711f11391de54b13dc8a628c80617ca5d25f070/source/daplink/cmsis-dap/DAP_vendor.c ;  0x0001c200 = 115,200kBps\r\n          .then(() => { callback(\"connected\", device, null); return Promise.resolve()}) \r\n          .then(transferLoop)\r\n          .catch(error => callback(\"error\", device, error))\r\n}\r\n\r\n/**\r\n * Disconnect from a device \r\n * @param {USBDevice} device to disconnect from \r\n */\r\nexport function uBitDisconnect(device) {\r\n    if(device && device.opened) {\r\n        device.close()\r\n    }\r\n}\r\n\r\n/**\r\n * Send a string to a specific device\r\n * @param {USBDevice} device \r\n * @param {string} data to send (must not include newlines)\r\n */\r\nfunction uBitSend(device, data) {\r\n    if(!device.opened)\r\n        return\r\n    // Need to send 0x84 (command), length (including newline), data's characters, newline\r\n    let fullLine = data+'\\n'\r\n    let encoded = new TextEncoder(\"utf-8\").encode(fullLine)\r\n    let message = new Uint8Array(1+1+fullLine.length)\r\n    message[0] = 0x84\r\n    message[1] = encoded.length\r\n    message.set(encoded, 2)\r\n    device.controlTransferOut(DAPOutReportRequest, message) // DAP ID_DAP_Vendor3: https://github.com/ARMmbed/DAPLink/blob/0711f11391de54b13dc8a628c80617ca5d25f070/source/daplink/cmsis-dap/DAP_vendor.c\r\n}\r\n\r\n\r\n/**\r\n * Callback for micro:bit events\r\n * \r\n \r\n   Event data varies based on the event string:\r\n  <ul>\r\n   <li>\"connection failure\": null</li>\r\n   <li>\"connected\": null</li>\r\n   <li>\"disconnected\": null</li>\r\n   <li>\"error\": error object</li>\r\n   <li>\"console\":  { \"time\":Date object \"data\":string}</li>\r\n   <li>\"graph-data\": { \"time\":Date object \"graph\":string \"series\":string \"data\":number}</li>\r\n   <li>\"graph-event\": { \"time\":Date object \"graph\":string \"series\":string \"data\":string}</li>\r\n  </ul>\r\n * @callback uBitEventCallback\r\n * @param {string} event (\"connection failure\", \"connected\", \"disconnected\", \"error\", \"console\", \"graph-data\", \"graph-event\" )\r\n * @param {USBDevice} device triggering the callback\r\n * @param {*} data (event-specific data object). See list above for variants\r\n * \r\n */\r\n\r\n\r\n/**\r\n * Allow users to select a device to connect to.\r\n * \r\n * @param {uBitEventCallback} callback function for device events\r\n */\r\nexport function uBitConnectDevice(callback) { \r\n    navigator.usb.requestDevice({filters: [{ vendorId: MICROBIT_VENDOR_ID, productId: 0x0204 }]})\r\n        .then(  d => { if(!d.opened) uBitOpenDevice(d, callback)} )\r\n        .catch( () => callback(\"connection failure\", null, null))\r\n}","import React from 'react';\r\nimport { Button, Icon } from 'semantic-ui-react';\r\nimport { uBitConnectDevice } from '../../utils/microbit-api';\r\n\r\n/**\r\n * AddMicroButton\r\n * @param {*} props\r\n *  onAddComplete: callback function when the mirco is added or failed to add\r\n *   The call back should take at least three parameters\r\n *     1. type: This is the type of message sent from the micro\r\n *     2. device: This is an id for the device\r\n *     3. data: Whatever data the micro sends \r\n */\r\nexport function AddMicroButton(props) {\r\n  let connectMicro = () => {\r\n    uBitConnectDevice(props.onAddComplete);\r\n  };\r\n\r\n  return (\r\n    <Button size=\"big\" onClick={(e) => connectMicro()}>\r\n      <Icon name=\"plus\" />Add Micro:bit\r\n    </Button>\r\n  );\r\n}\r\n","import React, {Component} from 'react';\r\nimport {Icon, Button} from 'semantic-ui-react';\r\n\r\nclass PlayButton extends Component {\r\n  render () {\r\n    return this.props.isRunning\r\n      ? <Button\r\n          icon\r\n          labelPosition=\"left\"\r\n          onClick={this.props.onClick}\r\n          color=\"red\"\r\n        >\r\n          <Icon name=\"pause\" />\r\n          Pause\r\n        </Button>\r\n      : <Button\r\n          icon\r\n          labelPosition=\"left\"\r\n          onClick={this.props.onClick}\r\n          color=\"green\"\r\n          style={{width: '115.28px'}}\r\n        >\r\n          <Icon name=\"play\" />\r\n          Play\r\n        </Button>;\r\n  }\r\n}\r\n\r\nexport default PlayButton;\r\n","import React, {Component} from 'react';\r\nimport {Icon, Button} from 'semantic-ui-react';\r\nimport * as FileSaver from 'file-saver';\r\nimport * as XLSX from 'xlsx';\r\n\r\nclass SaveDataButton extends Component {\r\n  render () {\r\n    const fileType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8';\r\n    const fileExtension = '.csv';\r\n\r\n    const exportToCSV = (csvData, fileName) => {\r\n        const ws = XLSX.utils.json_to_sheet(csvData);\r\n        const wb = { Sheets: { 'data': ws }, SheetNames: ['data'] };\r\n        const excelBuffer = XLSX.write(wb, { bookType: 'csv', type: 'array' });\r\n        const data = new Blob([excelBuffer], {type: fileType});\r\n        FileSaver.saveAs(data, fileName + fileExtension);\r\n    }\r\n    return (\r\n      <Button\r\n        icon\r\n        labelPosition=\"left\"\r\n        onClick={(e)=> exportToCSV(this.props.csvData, this.props.fileName)}\r\n        color=\"grey\"\r\n        style={{width: '115.28px'}}\r\n      >\r\n        <Icon name=\"save\" />\r\n        Save\r\n      </Button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SaveDataButton;\r\n","import React from 'react';\r\nimport { Button } from 'semantic-ui-react';\r\n\r\nexport function DisconnectMicroButton(props) {\r\n  let disconnectMicro = () => {\r\n    props.disconnectDevice(props.device);\r\n  };\r\n\r\n  return (\r\n    <Button size=\"big\" onClick={(e) => disconnectMicro()}>\r\n      Disconnect Device\r\n    </Button>\r\n  );\r\n}\r\n\r\nexport default DisconnectMicroButton;\r\n","import React, {Component} from 'react';\r\nimport Chart from 'react-apexcharts';\r\n\r\nclass BrushChart extends Component {\r\n  render () {\r\n    return (\r\n      <div>\r\n        <Chart options={this.props.options} series={this.props.series} />\r\n        <Chart\r\n          options={this.props.optionsLine}\r\n          series={this.props.seriesLine}\r\n          type=\"area\"\r\n          height={this.props.optionsLine.chart.height}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BrushChart;\r\n","import React, {Component} from 'react';\r\nimport {Button, Header, Container} from 'semantic-ui-react';\r\n\r\nclass Title extends Component {\r\n  render () {\r\n    return  (\r\n        <Container textAlign=\"center\">\r\n            <Header content={this.props.title} size=\"huge\" style={{color: '#FFF'}}/>\r\n        </Container>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Title;\r\n","import React, { Component } from 'react';\r\nimport { Container, Table, Divider, Statistic, Icon } from 'semantic-ui-react';\r\nimport PlayButton from './components/PlayButton';\r\nimport SaveDataButton from './components/SaveData';\r\nimport DisconnectMicroButton from './components/DisconnectMicroButton';\r\nimport BrushChart from './components/BrushChart';\r\nimport moment from 'moment';\r\nimport Title from './components/Title';\r\n\r\nclass MicrobitGraph extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Container>\r\n          <Title title={this.props.title} />\r\n          <Table definition textAlign=\"center\">\r\n            <Table.Body>\r\n              <Table.Row>\r\n                <Table.Cell width={2} verticalAlign=\"top\">\r\n                  <PlayButton\r\n                    isRunning={this.props.isRunning}\r\n                    onClick={this.props.playOnClick}\r\n                  />\r\n\r\n                  <Divider hidden />\r\n\r\n                  <SaveDataButton\r\n                    csvData={this.props.csvData}\r\n                    fileName={'microbit-usb-data-' + moment().format('MM-DD')}\r\n                  />\r\n\r\n                  <Divider hidden />\r\n\r\n                  <DisconnectMicroButton\r\n                    device={this.props.device}\r\n                    disconnectDevice={this.props.disconnectDevice.bind(this)}\r\n                  />\r\n\r\n                  <Statistic size=\"mini\" style={{}}>\r\n                    <Statistic.Value>\r\n                      <Icon name=\"clock outline\" /> 0\r\n                    </Statistic.Value>\r\n                    <Statistic.Label>Time Elapsed</Statistic.Label>\r\n                  </Statistic>\r\n                </Table.Cell>\r\n                <Table.Cell>\r\n                  <BrushChart\r\n                    options={this.props.options}\r\n                    series={this.props.series}\r\n                    optionsLine={this.props.optionsLine}\r\n                    seriesLine={this.props.seriesLine}\r\n                    height={this.props.height}\r\n                    areaHeight={this.props.areaHeight}\r\n                  />\r\n                </Table.Cell>\r\n              </Table.Row>\r\n            </Table.Body>\r\n          </Table>\r\n        </Container>\r\n        <Divider hidden />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MicrobitGraph;\r\n","import React, { Component } from 'react';\r\nimport {\r\n  Container,\r\n  Segment,\r\n  Rail,\r\n  Sticky,\r\n  Statistic,\r\n  Icon,\r\n} from 'semantic-ui-react';\r\n\r\nclass StickyStatistics extends Component {\r\n  render() {\r\n    return (\r\n      <Container>\r\n        <Segment style={{ backgroundColor: '#252839' }}>\r\n          <Rail position=\"right\">\r\n            <Sticky>\r\n              <Segment textAlign=\"center\">\r\n                <Statistic.Group>\r\n                  <Statistic>\r\n                    <Statistic.Value>\r\n                      <Icon name=\"usb\" /> {this.props.microbitsConnected}\r\n                    </Statistic.Value>\r\n                    <Statistic.Label>Microbits Connected</Statistic.Label>\r\n                  </Statistic>\r\n                </Statistic.Group>\r\n              </Segment>\r\n            </Sticky>\r\n          </Rail>\r\n        </Segment>\r\n      </Container>\r\n    );\r\n  }\r\n}\r\n\r\nexport default StickyStatistics;\r\n","import React, { createRef } from 'react';\r\nimport '../../styles/App.css';\r\nimport { Container, Divider } from 'semantic-ui-react';\r\nimport { Header, Icon } from 'semantic-ui-react';\r\nimport { SideNav } from '../../components/SideNav';\r\nimport { AddMicroButton } from '../../components/AddMicroButton';\r\nimport { uBitDisconnect } from '../../utils/microbit-api';\r\nimport MicrobitGraph from '../../components/MicrobitGraph';\r\nimport StickyStatistics from '../../components/StickyStatistics';\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      // mirco connections\r\n      devices: {},\r\n      isRunning: false,\r\n      microbitsConnected: 0,\r\n      graphs: [],\r\n      options: {\r\n        chart: {\r\n          id: 'chart2',\r\n          type: 'line',\r\n          height: 230,\r\n          toolbar: {\r\n            autoSelected: 'pan',\r\n            show: false,\r\n          },\r\n        },\r\n        colors: ['#546E7A'],\r\n        stroke: {\r\n          width: 3,\r\n        },\r\n        dataLabels: {\r\n          enabled: false,\r\n        },\r\n        fill: {\r\n          opacity: 1,\r\n        },\r\n        markers: {\r\n          size: 0,\r\n        },\r\n        xaxis: {\r\n          type: 'date',\r\n          categories: [],\r\n        },\r\n      },\r\n\r\n      seriesLine: [\r\n        {\r\n          data: [\r\n            '2019-11-30T08:17:24.220Z',\r\n            '2019-12-30T08:17:24.220Z',\r\n            '2020-1-30T08:17:24.220Z',\r\n          ],\r\n        },\r\n      ],\r\n      optionsLine: {\r\n        chart: {\r\n          id: 'chart1',\r\n          height: 130,\r\n          type: 'area',\r\n          brush: {\r\n            target: 'chart2',\r\n            enabled: true,\r\n          },\r\n          selection: {\r\n            enabled: true,\r\n          },\r\n        },\r\n        colors: ['#008FFB'],\r\n        fill: {\r\n          type: 'gradient',\r\n          gradient: {\r\n            opacityFrom: 0.91,\r\n            opacityTo: 0.1,\r\n          },\r\n        },\r\n        xaxis: {\r\n          type: 'date',\r\n          tooltip: {\r\n            enabled: false,\r\n          },\r\n        },\r\n        yaxis: {\r\n          tickAmount: 2,\r\n        },\r\n      },\r\n      seconds: 0,\r\n    };\r\n\r\n    this.microbitCallBack = this.microbitCallBack.bind(this);\r\n  }\r\n\r\n  microbitCallBack(type, device, data) {\r\n    if (type === 'connected') {\r\n      let devices = this.state.devices;\r\n      devices[device.serialNumber] = device;\r\n      this.setState({ devices: devices });\r\n      this.createGraph(device);\r\n    }\r\n  }\r\n\r\n  disconnectDevice(device) {\r\n    uBitDisconnect(device);\r\n    let devices = this.state.devices;\r\n    let graphs = this.state.graphs;\r\n    delete devices[device.serialNumber];\r\n    delete graphs[device.serialNumber];\r\n    this.setState({\r\n      graphs: graphs,\r\n      devices: devices,\r\n      microbitsConnected: this.state.microbitsConnected - 1,\r\n    });\r\n  }\r\n\r\n  createGraph(device) {\r\n    if (this.state.graphs[device.serialNumber] === undefined) {\r\n      let graphs = this.state.graphs;\r\n      graphs[device.serialNumber] = {\r\n        deviceSerial: device.serialNumber,\r\n        title: 'Micro:bit Graph ' + device.vendorId,\r\n        isRunning: false,\r\n        timeElapsed: 0,\r\n        series: [\r\n          {\r\n            data: [],\r\n          },\r\n        ],\r\n      };\r\n      this.setState({\r\n        graphs: graphs,\r\n        microbitsConnected: this.state.microbitsConnected + 1,\r\n      });\r\n    }\r\n  }\r\n\r\n  contextRef = createRef();\r\n\r\n  render() {\r\n    var arr = [2, 5, 6, 3, 8, 9];\r\n\r\n    var csvData = arr.map(function(val, index) {\r\n      return { key: index, value: val * val };\r\n    });\r\n\r\n    const graphs = this.state.graphs;\r\n\r\n    return (\r\n      <div>\r\n        <Header as=\"h2\" icon inverted textAlign=\"center\">\r\n          <Icon name=\"line graph\" />\r\n          Micro: bit USB Grapher\r\n          <Header.Subheader>\r\n            Collect and graph data on one or more Micro: bits!\r\n          </Header.Subheader>\r\n        </Header>\r\n        <Divider />\r\n        <StickyStatistics\r\n          microbitsConnected={this.state.microbitsConnected}\r\n          timeElapsed={this.state.timeElapsed}\r\n        />\r\n        <Container>\r\n          <AddMicroButton onAddComplete={this.microbitCallBack} />\r\n          {graphs &&\r\n            Object.keys(graphs).map((key, index) => {\r\n              return (\r\n                <div>\r\n                  <MicrobitGraph\r\n                    device={this.state.devices[key]}\r\n                    title={graphs[key].title}\r\n                    csvData={csvData}\r\n                    options={this.state.options}\r\n                    series={graphs[key].series}\r\n                    optionsLine={this.state.optionsLine}\r\n                    seriesLine={this.state.seriesLine}\r\n                    height={this.state.height}\r\n                    areaHeight={this.state.areaHeight}\r\n                    isRunning={graphs[key].isRunning}\r\n                    playOnClick={() => {\r\n                      graphs[key].isRunning = false\r\n                        ? false\r\n                        : true;\r\n                      this.setState({\r\n                        graphs: graphs,\r\n                      });\r\n                    }}\r\n                    disconnectDevice={this.disconnectDevice.bind(this)}\r\n                  />\r\n                </div>\r\n              );\r\n            })}\r\n        </Container>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './styles/index.css';\r\nimport App from './containers/Home/App';\r\nimport * as serviceWorker from './utils/serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}